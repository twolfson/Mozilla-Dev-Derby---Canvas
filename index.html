<!doctype>
<html>
<head>
	<title>MDN Derby - October 2011</title>
	<style>
    /* Visual fixes (poor man's reset/normalize.css) */
		* {
			margin: 0;
			padding: 0;
		}

    #header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;

      text-align: center;
      cursor: default;
      color: #CCC;
    }

    #canvas {
      /* TODO: Use subtle background */
      background: #333;
    }
	</style>
</head>
<body>
<h1 id="header">Touch anywhere to start.</h1>
<canvas id="canvas"></canvas>
<script>
  var body = document.body,
      header = document.getElementById('header'),
      headerInitText = header.innerHTML,
      headerMoveText = "Move your mouse around the screen.",
      canvas = document.getElementById('canvas'),
      ctx = canvas.getContext('2d'),
      lastX,
      lastY;

  // Create the gradient queue
  // Green -> Yellow -> Red -> Purple
  // TODO: Massively increase size of stroke
  // TODO: Break down strokes so that each is at most 5px distance from the next
  // TODO: Execute color queue on them
  // TODO: Do a timer instead of mousemove (in case of idle click)
  function createGradientQueue(x1, y1, x2, y2) {
    // Begin with green
    var _gradientQueue = ['#0F0'],
        gradient;

    // Finish with purple
    gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    gradient.addColorStop(0, '#F0F');
    gradient.addColorStop(1, '#F0F');
    _gradientQueue.push(gradient);
    
    // Reverse removal order (stack to queue)
    _gradientQueue.reverse();

    return _gradientQueue;
  }

  // Set canvas to full screen
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;

  function _eventWrapper(fn) {
    return function (e) {
      // Get the true event
      e = e || window.event;

      // Method to prevent default behavior
      if( !e.preventDefault ) {
        e.preventDefault = function () {
          e.returnValue = false;
        };
      }

      // Method to stop propagation
      if( !e.stopPropagation ) {
        e.stopPropagation = function () {
          e.cancelBubble = true;
        };
      }

      // Method to stop everything
      e.stopNormal = function () {
        e.preventDefault();
        e.stopPropagation();
      };

      // Invoke fn with wrapped event
      fn(e);
    }
  }

  function _drawLine(x1, y1, x2, y2) {
    // Start path
    ctx.beginPath();
    ctx.moveTo(x1, y1);

    // Continue path
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // Terminate path
    ctx.closePath();
  }

  function heatStroke(x1, y1, x2, y2) {
    // Copy the gradeient queue
    var gradientQueue = createGradientQueue(x1, y1, x2, y2);

    // Change the color to green
    ctx.strokeStyle = gradientQueue.pop();

    // Draw out the stroke
    _drawLine(x1, y1, x2, y2);

    // Start the color transitions in 1 second
    setTimeout(function () {
      function smoothTransition() {
        // Retrieve the next gradient
        var nextGradient = gradientQueue.pop();
        if( !nextGradient ) {
          return;
        }

        // Change the color to the next gradient and overwrite stroke
        ctx.strokeStyle = nextGradient;
        _drawLine(x1, y1, x2, y2);

        // Queue up the next transition
        setTimeout(smoothTransition, 100);
      }

      // Begin smooth transition loop
      smoothTransition();
    }, 1000);
  }

  var _moveFn = _eventWrapper(function (e) {
    // Stop normal default behavior/bubbling
    e.stopNormal();

    // Mark the stroke down
    var x = e.clientX,
        y = e.clientY;
    heatStroke(lastX, lastY, x, y);

    // Save position for next move
    lastX = x;
    lastY = y;
  }),

  _upFn = _eventWrapper(function (e) {
    // Stop normal default behavior/bubbling
    e.stopNormal();

    // Reset header text
    header.innerHTML = headerInitText;

    // Remove bindings
    body.onmousemove = null;
    body.onmouseup = null;
  });

  // Bind onclick watching
  body.onmousedown = _eventWrapper(function (e) {
    // Stop normal default behavior/bubbling
    e.stopNormal();

    // Memoize current location
    lastX = e.clientX;
    lastY = e.clientY;

    // Change header text
    header.innerHTML = headerMoveText;

    // Bind any motion and halting
    body.onmousemove = _moveFn;
    body.onmouseup = _upFn;
  });
</script>
</body>
</html>